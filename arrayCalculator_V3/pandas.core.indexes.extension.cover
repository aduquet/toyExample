    1: """
       Shared methods for Index subclasses backed by ExtensionArray.
       """
    1: from __future__ import annotations
       
    1: from typing import (
           Callable,
           TypeVar,
       )
       
    1: import numpy as np
       
    1: from pandas._typing import (
           ArrayLike,
           npt,
       )
    1: from pandas.util._decorators import (
           cache_readonly,
           doc,
       )
       
    1: from pandas.core.dtypes.generic import ABCDataFrame
       
    1: from pandas.core.arrays import IntervalArray
    1: from pandas.core.arrays._mixins import NDArrayBackedExtensionArray
    1: from pandas.core.indexes.base import Index
       
    1: _T = TypeVar("_T", bound="NDArrayBackedExtensionIndex")
    1: _ExtensionIndexT = TypeVar("_ExtensionIndexT", bound="ExtensionIndex")
       
       
    1: def _inherit_from_data(
           name: str, delegate: type, cache: bool = False, wrap: bool = False
       ):
           """
           Make an alias for a method of the underlying ExtensionArray.
       
           Parameters
           ----------
           name : str
               Name of an attribute the class should inherit from its EA parent.
           delegate : class
           cache : bool, default False
               Whether to convert wrapped properties into cache_readonly
           wrap : bool, default False
               Whether to wrap the inherited result in an Index.
       
           Returns
           -------
           attribute, method, property, or cache_readonly
           """
  120:     attr = getattr(delegate, name)
       
  120:     if isinstance(attr, property) or type(attr).__name__ == "getset_descriptor":
               # getset_descriptor i.e. property defined in cython class
   74:         if cache:
       
    7:             def cached(self):
                       return getattr(self._data, name)
       
    7:             cached.__name__ = name
    7:             cached.__doc__ = attr.__doc__
    7:             method = cache_readonly(cached)
       
               else:
       
   67:             def fget(self):
                       result = getattr(self._data, name)
                       if wrap:
                           if isinstance(result, type(self._data)):
                               return type(self)._simple_new(result, name=self.name)
                           elif isinstance(result, ABCDataFrame):
                               return result.set_index(self)
                           return Index(result, name=self.name)
                       return result
       
   67:             def fset(self, value):
                       setattr(self._data, name, value)
       
   67:             fget.__name__ = name
   67:             fget.__doc__ = attr.__doc__
       
   67:             method = property(fget, fset)
       
   46:     elif not callable(attr):
               # just a normal attribute, no wrapping
               method = attr
       
           else:
               # error: Incompatible redefinition (redefinition with type "Callable[[Any,
               # VarArg(Any), KwArg(Any)], Any]", original type "property")
   46:         def method(self, *args, **kwargs):  # type: ignore[misc]
                   if "inplace" in kwargs:
                       raise ValueError(f"cannot use inplace with {type(self).__name__}")
                   result = attr(self._data, *args, **kwargs)
                   if wrap:
                       if isinstance(result, type(self._data)):
                           return type(self)._simple_new(result, name=self.name)
                       elif isinstance(result, ABCDataFrame):
                           return result.set_index(self)
                       return Index(result, name=self.name)
                   return result
       
               # error: "property" has no attribute "__name__"
   46:         method.__name__ = name  # type: ignore[attr-defined]
   46:         method.__doc__ = attr.__doc__
  120:     return method
       
       
    1: def inherit_names(
           names: list[str], delegate: type, cache: bool = False, wrap: bool = False
       ) -> Callable[[type[_ExtensionIndexT]], type[_ExtensionIndexT]]:
           """
           Class decorator to pin attributes from an ExtensionArray to a Index subclass.
       
           Parameters
           ----------
           names : List[str]
           delegate : class
           cache : bool, default False
           wrap : bool, default False
               Whether to wrap the inherited result in an Index.
           """
       
   14:     def wrapper(cls: type[_ExtensionIndexT]) -> type[_ExtensionIndexT]:
  134:         for name in names:
  120:             meth = _inherit_from_data(name, delegate, cache=cache, wrap=wrap)
  120:             setattr(cls, name, meth)
       
   14:         return cls
       
   14:     return wrapper
       
       
    2: class ExtensionIndex(Index):
    1:     """
           Index subclass for indexes backed by ExtensionArray.
           """
       
           # The base class already passes through to _data:
           #  size, __len__, dtype
       
    1:     _data: IntervalArray | NDArrayBackedExtensionArray
       
           # ---------------------------------------------------------------------
       
    1:     def _validate_fill_value(self, value):
               """
               Convert value to be insertable to underlying array.
               """
               return self._data._validate_setitem_value(value)
       
    1:     @doc(Index.map)
    1:     def map(self, mapper, na_action=None):
               # Try to run function on index first, and then on elements of index
               # Especially important for group-by functionality
               try:
                   result = mapper(self)
       
                   # Try to use this result if we can
                   if isinstance(result, np.ndarray):
                       result = Index(result)
       
                   if not isinstance(result, Index):
                       raise TypeError("The map function must return an Index object")
                   return result
               except Exception:
                   return self.astype(object).map(mapper)
       
    1:     @cache_readonly
    1:     def _isnan(self) -> npt.NDArray[np.bool_]:
               # error: Incompatible return value type (got "ExtensionArray", expected
               # "ndarray")
               return self._data.isna()  # type: ignore[return-value]
       
       
    2: class NDArrayBackedExtensionIndex(ExtensionIndex):
    1:     """
           Index subclass for indexes backed by NDArrayBackedExtensionArray.
           """
       
    1:     _data: NDArrayBackedExtensionArray
       
    1:     def _get_engine_target(self) -> np.ndarray:
               return self._data._ndarray
       
    1:     def _from_join_target(self, result: np.ndarray) -> ArrayLike:
               assert result.dtype == self._data._ndarray.dtype
               return self._data._from_backing_data(result)
